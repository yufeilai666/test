name: 2 Update EPG Files

on:
  workflow_dispatch:  # æ‰‹åŠ¨è§¦å‘
  schedule:
    - cron: '30 */4 * * *'  # UTCæ—¶é—´æ¯4å°æ—¶çš„30åˆ†é’Ÿè¿è¡Œ

jobs:
  update-epg:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests pytz
        
    - name: Create epg directory if not exists
      run: mkdir -p epg
      
    - name: Download EPG files with retry
      run: |
        cat > download_epg.py << 'EOF'
        import json
        import requests
        import os
        import time
        from pathlib import Path
        import concurrent.futures
        from threading import Lock

        # è¯»å–é…ç½®æ–‡ä»¶
        with open('files.json', 'r', encoding='utf-8') as f:
            config = json.load(f)

        epg_urls = config.get('epg_url', {})
        epg_dir = Path('epg')

        # ç¡®ä¿ç›®å½•å­˜åœ¨
        epg_dir.mkdir(exist_ok=True)

        # åˆ›å»ºé”ç”¨äºçº¿ç¨‹å®‰å…¨çš„è®¡æ•°å’Œæ‰“å°
        print_lock = Lock()
        success_count = 0
        fail_count = 0

        def download_single_epg(item):
            global success_count, fail_count
            filename, url = item
            max_retries = 3
            retry_delay = 2  # é‡è¯•å»¶è¿Ÿç§’æ•°
            
            for attempt in range(max_retries):
                try:
                    with print_lock:
                        print(f"ğŸš€ æ­£åœ¨ä¸‹è½½: {filename} (å°è¯• {attempt + 1}/{max_retries})")
                    
                    # è®¾ç½®è¯·æ±‚å¤´
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (compatible; GitHub-Actions-EPG-Downloader/1.0)',
                        'Accept-Encoding': 'gzip'
                    }
                    
                    # ä¸‹è½½æ–‡ä»¶
                    response = requests.get(url, headers=headers, timeout=60)
                    response.raise_for_status()  # å¦‚æœçŠ¶æ€ç ä¸æ˜¯200ä¼šæŠ›å‡ºå¼‚å¸¸
                    
                    # ä¿å­˜æ–‡ä»¶
                    file_path = epg_dir / filename
                    with open(file_path, 'wb') as f:
                        f.write(response.content)
                    
                    file_size = len(response.content)
                    with print_lock:
                        print(f"âœ… æˆåŠŸä¸‹è½½: {filename} ({file_size} å­—èŠ‚)")
                        print("*"*36)
                        success_count += 1
                    return True  # æˆåŠŸåˆ™è·³å‡ºé‡è¯•å¾ªç¯
                    
                except Exception as e:
                    with print_lock:
                        print(f"âš ï¸ ä¸‹è½½å¤±è´¥ {filename} (å°è¯• {attempt + 1}/{max_retries}): {str(e)}")
                    
                    # å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ä»ç„¶å¤±è´¥
                    if attempt == max_retries - 1:
                        with print_lock:
                            print(f"âŒ æ”¾å¼ƒä¸‹è½½ {filename}ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                            print("*"*36)
                            fail_count += 1
                        return False
                    else:
                        # ä¸æ˜¯æœ€åä¸€æ¬¡å¤±è´¥ï¼Œç­‰å¾…åé‡è¯•
                        with print_lock:
                            print(f"\nâ³ï¸ ç­‰å¾… {retry_delay} ç§’åé‡è¯• {filename}...")
                        time.sleep(retry_delay)
                        retry_delay *= 1.5  # æŒ‡æ•°é€€é¿ç­–ç•¥

        print(f"â¬‡ï¸ å¼€å§‹ä¸‹è½½ {len(epg_urls)} ä¸ªEPGæ–‡ä»¶...")
        print("="*36 + "\n")
        print("*"*36)

        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œä¸‹è½½ï¼Œæœ€å¤§å¹¶å‘æ•°ä¸º5
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            # æäº¤æ‰€æœ‰ä¸‹è½½ä»»åŠ¡
            futures = {executor.submit(download_single_epg, item): item for item in epg_urls.items()}
            
            # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
            for future in concurrent.futures.as_completed(futures):
                filename = futures[future][0]
                try:
                    future.result()  # è·å–ç»“æœï¼Œå¦‚æœæœ‰å¼‚å¸¸ä¼šåœ¨è¿™é‡ŒæŠ›å‡º
                except Exception as e:
                    with print_lock:
                        print(f"âŒ ä¸‹è½½ä»»åŠ¡å¼‚å¸¸ {filename}: {str(e)}")

        print("\n" + "="*36)
        print(f"ğŸ‰ ä¸‹è½½å®Œæˆ: æˆåŠŸ {success_count} ä¸ª, å¤±è´¥ {fail_count} ä¸ª")

        # å¦‚æœæœ‰å¤±è´¥çš„æ–‡ä»¶ï¼Œä»¥ä»£ç 0é€€å‡ºï¼ˆä¸ä¸­æ–­å·¥ä½œæµï¼‰
        exit(0)
        EOF
        
        python download_epg.py
        
    - name: Clean up temporary script
      run: rm -f download_epg.py
        
    - name: Check for changes
      id: check_changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        echo "ğŸ“ EPGç›®å½•å†…å®¹:"
        ls -la epg/
        
        # æ›´ç›´æ¥çš„æ–¹æ³•ï¼šå…ˆæ·»åŠ epgç›®å½•åˆ°æš‚å­˜åŒºï¼Œç„¶åæ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
        git add epg/
        
        # æ£€æŸ¥æš‚å­˜åŒºä¸HEADä¹‹é—´æ˜¯å¦æœ‰å·®å¼‚
        if git diff --staged --quiet; then
          echo "changes=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ æ²¡æœ‰æ£€æµ‹åˆ°EPGæ–‡ä»¶å˜åŠ¨"
          # é‡ç½®æš‚å­˜åŒºï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰å®é™…å˜åŒ–
          git reset
        else
          echo "changes=true" >> $GITHUB_OUTPUT
          echo "â˜‘ï¸ æ£€æµ‹åˆ°EPGæ–‡ä»¶å˜åŠ¨"
          git status epg/
        fi
        
    - name: Get Beijing time
      if: steps.check_changes.outputs.changes == 'true'
      id: beijing_time
      run: |
        # å®‰è£…æ—¶åŒºæ•°æ®
        sudo apt-get update && sudo apt-get install -y tzdata
        
        # è·å–åŒ—äº¬æ—¶é—´å¹¶æ ¼å¼åŒ–ä¸ºæ‰€éœ€æ ¼å¼
        BEIJING_TIME=$(TZ='Asia/Shanghai' date +'%Y-%m-%d %H:%M')
        echo "beijing_time=$BEIJING_TIME" >> $GITHUB_OUTPUT
        echo "â²ï¸ å½“å‰åŒ—äº¬æ—¶é—´: $BEIJING_TIME"
        
    - name: Commit and push if changes
      if: steps.check_changes.outputs.changes == 'true'
      run: |
        git commit -m "ğŸ”„ è‡ªåŠ¨æ›´æ–°EPGæ–‡ä»¶ [${{ steps.beijing_time.outputs.beijing_time }}]"
        git push