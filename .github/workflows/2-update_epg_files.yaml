name: 2 Update EPG Files

on:
  workflow_dispatch:  # æ‰‹åŠ¨è§¦å‘
  schedule:
    - cron: '30 */4 * * *'  # UTCæ—¶é—´æ¯4å°æ—¶çš„30åˆ†é’Ÿè¿è¡Œ

jobs:
  update-epg:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests pytz
        
    - name: Create epg directory if not exists
      run: mkdir -p epg
      
    - name: Download EPG files with retry
      run: |
        cat > download_epg.py << 'EOF'
        import json
        import requests
        import os
        import time
        from pathlib import Path
        import concurrent.futures
        from threading import Lock
        from datetime import datetime
        import pytz

        # è¯»å–é…ç½®æ–‡ä»¶
        with open('files.json', 'r', encoding='utf-8') as f:
            config = json.load(f)

        epg_urls = config.get('epg_url', {})
        epg_dir = Path('epg')

        # ç¡®ä¿ç›®å½•å­˜åœ¨
        epg_dir.mkdir(exist_ok=True)

        # åˆ›å»ºé”ç”¨äºçº¿ç¨‹å®‰å…¨çš„è®¡æ•°å’Œæ‰“å°
        print_lock = Lock()
        success_count = 0
        fail_count = 0

        def format_time():
            # è®¾ç½®åŒ—äº¬æ—¶åŒº
            beijing_tz = pytz.timezone('Asia/Shanghai')
            # è·å–å½“å‰UTCæ—¶é—´å¹¶è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´
            beijing_time = datetime.now(beijing_tz)
            return beijing_time.strftime('%H:%M:%S')

        def download_single_epg(item):
            global success_count, fail_count
            filename, url = item
            max_retries = 5  # æœ€å¤§é‡è¯•æ¬¡æ•°
            retry_delay = 1.5  # é‡è¯•å»¶è¿Ÿç§’æ•°
            
            # ä¸ºæ¯ä¸ªæ–‡ä»¶åˆ›å»ºç‹¬ç«‹çš„æ—¥å¿—åˆ—è¡¨
            all_logs = []
            
            def add_log(message):
                all_logs.append(f"[{format_time()}] {message}")
            
            result = False
            for attempt in range(max_retries):
                try:
                    add_log(f"ğŸš€ å¼€å§‹ä¸‹è½½: {filename} (å°è¯• {attempt + 1}/{max_retries})")
                    
                    # è®¾ç½®è¯·æ±‚å¤´
                    headers = {
                        'User-Agent': 'AptvPlayer/2.1.2',
                        'Accept-Encoding': 'gzip'
                    }
                    
                    # ä¸‹è½½æ–‡ä»¶
                    response = requests.get(url, headers=headers, timeout=60)
                    response.raise_for_status()  # å¦‚æœçŠ¶æ€ç ä¸æ˜¯200ä¼šæŠ›å‡ºå¼‚å¸¸
                    
                    # ä¿å­˜æ–‡ä»¶
                    file_path = epg_dir / filename
                    with open(file_path, 'wb') as f:
                        f.write(response.content)
                    
                    file_size = len(response.content)
                    add_log(f"âœ… ä¸‹è½½æˆåŠŸ: {filename} ({file_size:,} å­—èŠ‚)")
                    result = True
                    break  # æˆåŠŸåˆ™è·³å‡ºé‡è¯•å¾ªç¯
                    
                except Exception as e:
                    error_msg = str(e)
                    if "Read timed out" in error_msg:
                        error_msg = "è¿æ¥è¶…æ—¶"
                    elif "Connection broken" in error_msg:
                        error_msg = "è¿æ¥ä¸­æ–­"
                    
                    add_log(f"âš ï¸ ä¸‹è½½å¤±è´¥: {filename} (å°è¯• {attempt + 1}/{max_retries}) - {error_msg}")
                    
                    # å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ä»ç„¶å¤±è´¥
                    if attempt == max_retries - 1:
                        add_log(f"âŒ æ”¾å¼ƒä¸‹è½½: {filename} (å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°)")
                        result = False
                    else:
                        # ä¸æ˜¯æœ€åä¸€æ¬¡å¤±è´¥ï¼Œç­‰å¾…åé‡è¯•
                        add_log(f"â³ ç­‰å¾… {retry_delay:.2f} ç§’åé‡è¯•...")
                        time.sleep(retry_delay)
                        retry_delay *= 1.2  # æŒ‡æ•°é€€é¿ç­–ç•¥
            
            # ä¸€æ¬¡æ€§è¾“å‡ºè¿™ä¸ªæ–‡ä»¶çš„æ‰€æœ‰æ—¥å¿—
            with print_lock:
                for log_line in all_logs:
                    print(log_line)
                print("â”€" * 22)
                
                if result:
                    success_count += 1
                else:
                    fail_count += 1
            
            return result

        print("=" * 36)
        print(f"ğŸ“¥ å¼€å§‹ä¸‹è½½ EPG æ–‡ä»¶â€¦")
        print(f"ğŸ“Š æ€»è®¡æ–‡ä»¶æ•°: {len(epg_urls)} ä¸ª")
        print(f"ğŸ•’ å¼€å§‹æ—¶é—´(UTC+8): {format_time()}")
        print("=" * 36)
        print("â”€" * 22)

        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œä¸‹è½½ï¼Œæœ€å¤§å¹¶å‘æ•°ä¸º5
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            # æäº¤æ‰€æœ‰ä¸‹è½½ä»»åŠ¡
            futures = {executor.submit(download_single_epg, item): item for item in epg_urls.items()}
            
            # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
            for future in concurrent.futures.as_completed(futures):
                filename = futures[future][0]
                try:
                    future.result()  # è·å–ç»“æœï¼Œå¦‚æœæœ‰å¼‚å¸¸ä¼šåœ¨è¿™é‡ŒæŠ›å‡º
                except Exception as e:
                    with print_lock:
                        print(f"[{format_time()}] âŒ ä¸‹è½½ä»»åŠ¡å¼‚å¸¸ {filename}: {str(e)}")
                        print("â”€" * 22)

        print("=" * 36)
        print(f"ğŸ“Š ä¸‹è½½å®ŒæˆæŠ¥å‘Š")
        print(f"âœ… æˆåŠŸ: {success_count} ä¸ªæ–‡ä»¶")
        print(f"âŒ å¤±è´¥: {fail_count} ä¸ªæ–‡ä»¶")
        print(f"ğŸ•’ ç»“æŸæ—¶é—´(UTC+8): {format_time()}")
        print("=" * 36)

        # å¦‚æœæœ‰å¤±è´¥çš„æ–‡ä»¶ï¼Œä»¥ä»£ç 0é€€å‡ºï¼ˆä¸ä¸­æ–­å·¥ä½œæµï¼‰
        exit(0)
        EOF
        
        python download_epg.py
        
    - name: Clean up temporary script
      run: rm -f download_epg.py
        
    - name: Check for changes
      id: check_changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        echo "ğŸ“ EPGç›®å½•å†…å®¹:"
        ls -la epg/
        
        # æ›´ç›´æ¥çš„æ–¹æ³•ï¼šå…ˆæ·»åŠ epgç›®å½•åˆ°æš‚å­˜åŒºï¼Œç„¶åæ£€æŸ¥æ˜¯å¦æœ‰å·®å¼‚
        git add epg/
        
        # æ£€æŸ¥æš‚å­˜åŒºä¸HEADä¹‹é—´æ˜¯å¦æœ‰å·®å¼‚
        if git diff --staged --quiet; then
          echo "changes=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ æ²¡æœ‰æ£€æµ‹åˆ°EPGæ–‡ä»¶å˜åŠ¨"
          # é‡ç½®æš‚å­˜åŒºï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰å®é™…å˜åŒ–
          git reset
        else
          echo "changes=true" >> $GITHUB_OUTPUT
          echo "â˜‘ï¸ æ£€æµ‹åˆ°EPGæ–‡ä»¶å˜åŠ¨"
          git status epg/
        fi
        
    - name: Get Beijing time
      if: steps.check_changes.outputs.changes == 'true'
      id: beijing_time
      run: |
        # å®‰è£…æ—¶åŒºæ•°æ®
        sudo apt-get update && sudo apt-get install -y tzdata
        
        # è·å–åŒ—äº¬æ—¶é—´å¹¶æ ¼å¼åŒ–ä¸ºæ‰€éœ€æ ¼å¼
        BEIJING_TIME=$(TZ='Asia/Shanghai' date +'%Y-%m-%d %H:%M')
        echo "beijing_time=$BEIJING_TIME" >> $GITHUB_OUTPUT
        echo "â²ï¸ å½“å‰åŒ—äº¬æ—¶é—´: $BEIJING_TIME"
        
    - name: Commit and push if changes
      if: steps.check_changes.outputs.changes == 'true'
      run: |
        git commit -m "ğŸ”„ è‡ªåŠ¨æ›´æ–°EPGæ–‡ä»¶ [${{ steps.beijing_time.outputs.beijing_time }}]"
        git push